 1.堆内存
    堆内存的分配效率比较高，读写效率比较低。主要是牵扯到内核态，用户态的数据复制，
    内存数据逻辑地址映射到地址，获取磁盘数据时，需要先从磁盘加载到内核态缓冲区，然后从内核态将数据复制到用户态。比较消耗时间及cpu资源。
    这里强调一点，数据从内核复制到用户态时，仍然需要cpu介入，DMA不是可以处理的。

 2.直接内存
    2.1直接内存分配效率比较低，但是读写效率高，

    2.2怎么讲呢，数据从磁盘加载到内核缓冲区，只需要映射一个地址到堆内存空间，就可以同时共享一个地址空间。
        减少了一次内核态到用户态数据复制的过程。所以频繁IO操作，直接内存更显优势。

    2.3直接内存不受JVM垃圾回收的管理，但需要格外注意释放这部分内存，一般配合虚引用完成。
        为什么直接内存分配效率低呢？通过Java程序分配直接内存，需要牵扯到用户态到内核态的切换，在内核态分配物理内存完成以后，通过mmap将
        这部分内存映射到Jvm内存中直接访问使用，又需要发生一次内核态和用户态的切换。所以直接内存分配效率比较低。


 3.ByteBuf池化
    3.1 池化的最大意义在于可以重用ByteBuf。
        没有池化，每次都得重新创建新的ByteBuf实例，这个操作对于直接内存来说比较昂贵，对于堆内存来说，也增加了GC的压力。
        高并发时,池化更节约内存，减少内存溢出的风险

 4.ByteBuf非池化
 5.ByteBuf组成
   读指针，写指针，容量，最大容量,支持动态扩容。最大容量为整数的最大值.默认容量为256字节。
   扩容规则以512为界限，超过512，则扩大到512的一倍。

 6.ByteBuf内存回收
    堆内存只需要等GC回收就可以，直接内存需要特殊的方法来回收，最好是手动释放

    Netty采用了引用计数器来控制内存回收。ByteBuf初始为1，调用release进行释放，retain进行加1.当计数器为0的时候会被回收
    释放规则，谁是最后的使用者，谁进行释放。在handler链可以由，头尾handler进行检查释放

 7.slice切片
    跟原有的ByteBuf共有这部分数据内存空间，只是逻辑上进行了分割。

 8.ByteBuf优势
    池化，可以进行重用，节约内存。
    读写指针分离，不需要切换模式
    可以自动扩容
    支持体现了零拷贝